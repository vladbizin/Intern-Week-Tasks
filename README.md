# Intern-Week-Tasks
## Описание и решение задач с Контеста на стажировку Yandex Intern Week Offer 2023

Всем привет, в этом репозитории я разместил условия и (свои) решения задач на языке C++. Сделал я это исключительно в ознакомительном плане, чтобы у людей не возникало вопросв, какие задачи могут быть на контесте.
Ниже распишу подход к каждой задаче.

## **A. USB-порты**
Задача больше математическая, чем алгоритмическая. У нас всего **m** гаджетов и **n** портов. Это значит, что нам нужно еще **m - n** портов. Заметим, что разветвитель USB с одного на два позволит нам подключить один дополнительный гаджет,
а разветвитель USB с одного на пять - 4 дополнительных наджета. Отсюда и решение: если 4 разветвителя на 2 стоят дешевле (или столько же как) сколько один на 5, то просто покупаем **m - n** разветвителей на два. В ином случае покупаем
**(m - n) / 4** разветвителей на 5, и у нас останется еще **(m - n) % 4** неподключенных гаджетов. Тут смотрим, что будет дешевле: купить один разветвитель на 5 или **(m - n) % 4** на 2. Общая сложность *O(1)* и по времени, и по памяти.

## **B. Ровный забор**
Сортируем доски по высоте. Затем идем скользящим окном ширины **n - k** по этому массиву, на каждом шаге обновляя минимальную разницу между крайними досками. В том окне, в котором разница в выостах крайних досок минимальна находятся все
доски, из которых требуется построить забор. Общая сложность *O(n)* и по времени, и по памяти.

## **C. Наследование репозиториев**
Очевидно, по условию задачи Васе требуется внести изменение в самый глубокий (вложенный) репозиторий. Создаем вектор, в котором по индексу репозитрия будем хранить его высоту (вложенность). Теперь по мере того, как мы получаем репозитории
(в i-ой строке id репозитория, от которого наследуется i-ый), мы зыаписываем в вектор его глубину как глубина[id] + 1. Теперь наш вектор содержит глубину каждого репозитория и за линейное время мы находим индекс самого глубокого. общая 
сложность *O(n)* и по времени, и по памяти.

## **D. Раскопки и плитка**
Общая идея следующая. В векторе ***last_job_day** по индексу i храним, в какой день на тротуаре i проводили раскопки в последний раз. Этот вектор нам нужен, чтобы в вектор **sad_intervals** записывать длину временных интервалов между подряд
идущими раскопками (количество потенциальных единиц печали). Если же раскопки на тротуаре i еще не проводились **last_job_day[i] = 0**, значит мы уменьшаем **m** на 1 (так как теперь на тротуаре i гарантировано надо делать ремонт). Таким образом выходу из первого цикла **m** будем
равно числу оставшихся ремонтов, которые мы можем выполнить. Теперь осортируем вектор **sad_intervals**, тогда сумма его - это вся печаль, которую мы можем получить, если не сделаем дополнительные ремонты. Теперь мы может отремонтировать
просто плитки, которые дают самый большой вклад - **m** последних в векторе **sad_intervals**. Теперт остается только посчитать сумму первых оставшихся. Описание решения может быть достаточно непонятное, но нарисуйте задачу на бумаге и вам
станет намного понятнее. Общая сложность *O(N logN)* по времени и *О(n + k)* по памяти.

## **E. Поступление с приоритетами**
Идея следующая. Мы будем иметь бинарное дерево поиска **abit_of_rank**, которое по ключу rk хранит список студентов, которые находятся на rk месте в рейтинге. В векторе **desired_progs_of_abit** по индексу студента храним список его
приоритетных программ (по убыванию приоритета). Теперь остается только пройтись по каждому студенту в **abit_of_rank** (мы будем итерироваться по студентам в порядке убывания рейтинга, так как **abit_of_rank** - бинарное дерево поиска).
Затем для каждого студентся проходимся по его списку (он уже в порядке приоритета) и смотрим, есть ли на желаемой программе места. Если есть, то записываем его на эту программу и уменьшаем количество мест на ней, иначе записываем на следующую
в приоритете (если на ней есть свободные  места) и т.д. если дошли до конца списка приоритетов текущего студента, значит он никуда не поступит. Такое решение автоматически удовлетворяет условиям задачи, так как мы итерируемся по студентам и 
их желаемых программам в порядке убывания рейтинга и приоритета соответственно. Общая сложность *O(n (logn + s))* по времени и *O(ns)* по памяти.

Как можно заметить, задачи вовсе не сложные. Главное - понять, что от вас требуется.
